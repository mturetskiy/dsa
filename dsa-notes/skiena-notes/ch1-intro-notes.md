# Basics
- It is very important to narrow set of allowable instances thus making the problem solvable as one of known algo.
- Start with super small examples to verify or prove incorrectness of the algo.
- Check weaknesses of the algo (e.g. greedy algo works as "take the biggest", so it can be used to find counter-example)
- Check the tie case.
- Check the extremes.

# Recursion
- Recursion idea: big things are made from smaller things of exactly the same type as the big thing.
- Recursion is used in most of the algos and super important aspect.
- Recursion is mathematical induction in action.
- To implement recursion you need to define initial case (boundary) which will terminate the recursion.
- Recursion requires:
  - decomposition rule
  - base case - define salest & simplest object where decomposition (and recursion) stops.

# Common algo structures
- Permutation - reordering of elements
- Subset - selection from a set of items
- Tree - represents hierarchical relationships of elements
- Graph - represents relationships between pairs of elements
- Point - location in some space
- Polygon - regions in some space
- String - sequence of chars.

# Estimation
 - Estimation could be of two types:
   - Principled calculation - give the answer based on knowledge that can be checked in Google or **feel confident enough to guess**.
   - Analogy - based on you past experience and **similarity** with current problem.

# Introduced & mentioned
## Algo
 - Insertion Sort
## Problems
 - Traveling salesman problem (TSP) - the salesman needs to find fastest way to meet all cities.
 - Movie Schedule Problem
 - Robot Tour optimization -> Nearest neighbour & Closest Pair